createdAt: "2019-11-13T04:22:30.716Z"
updatedAt: "2019-11-24T14:12:49.614Z"
type: "MARKDOWN_NOTE"
folder: "58a5d51f09911f5a02b7"
title: "go開発メモ"
tags: []
content: '''
  # go開発メモ
  
  ## カーディナリティとは
  テーブルにカラムがあるとして、カラムに格納されているデータの種類がどのくらいあるのか(カラムの値の種類の絶対値)を、カーディナリティという。
  
  ## 具体例
  
  ### カーディナリティが低い場合
  例えば性別なら、男と女の二種類である。
  カラムのデータの種類が、テーブルのレコード数に比べて二種類と少ない。このことを **カーディナリティが低い** という。
  
  ### カーディナリティが高い場合
  一方顧客番号ならたくさんの種類(番号)が存在することになる。
  カラムのデータの種類が、テーブルのレコード数に比べて多い場合、 **カーディナリティが高い** という。
  
  ## カーディナリティを踏まえたインデックスの張り方
  基本的に、 **カーディナリティの高い列に作成する** 必要がある。
  
  はじめに、カーディナリティは **カラムの値の種類の絶対値**と書いたが、先程の例で言うと性別のカーディナリティは2になる。他にも例えば１年間の日付なら1〜365なのでカーディナリティは365になる。カーディナリティが高いのは日付ということになる。
  
  インデックスを作る時の目安は特定のカラム値を指定した時に、全体の **5%**程度に絞り込めるだけのカーディナリティがあることである。例えば先ほどの日付の例だと、365日のうちの1日を指定するselect文を考えるとする。
  この場合 1 / 365 ≒ 0.27%となるので、インデックスを作成する意味はあるといえるだろう。
  反対に、性別の場合男女どちらを選んでも 1 / 2 = 50%となるので、インデックスを作成する意味はないし、むしろマイナスになるだろう。
  
  
  複合インデックスを貼る時は、 **カーディナリティの高い順**に貼っていくのが大事で、適当な順番にしてはいけない。これは直感的にも顧客番号のほうが明らかに検索する回数が多そうだから先に絞ってしまおうという考えになるだろう。
  
  ## 参考
  - http://promamo.com/?p=2207
  - http://www.shift-the-oracle.com/words/cardinality.html
  
  ### 実行計画
  
  sqlのチューニングで実行計画をとりたいときは
  EXPLAINをよく使うと思いますが、テーブルの使用パーティションを確認する際は
  
  
  EXPLAIN PARTITIONS {クエリ}
  
  で使用しているpartitions情報を取得できます。
  
  
  
  explain select * from user_hoge_log where start >= UNIX_TIMESTAMP('2019-09-01');
  
  |id|	select_type|	table|	partitions|	type|	possible_keys|	key|	key_len|	ref|	rows|	filtered|	Extra|
  |---|---|---|---|---|---|---|---|---|---|---|---|
  |1|	SIMPLE|	user_hoge_log|	p0,p1,p2,p3|	ALL|	NULL|	NULL|	NULL|	NULL|	2611|	33.33|	Using| where|
  
  ※パーティション化されていないテーブルで```EXPLAIN PARTITIONS```を使用すると、
  エラーは発生しませんが、partitionsカラムの値は常に NULL となります。
  
  
  ちなみに試してみたところ、
  
  MySQL5.6では```partitions```指定は明示的に必要でしたが、
  MySQL5.7では```partitions```指定はなしでもpartitions項目は表示されたのでデフォルトでオンのようです。
  
  ### インデックスオンリーサーチ
  ### インデックスとは何か
  - DBで作成できる索引情報のこと。
  - インデックスの存在する列に対して検索が行われた場合、DBMSはインデックスの使用を試みる為、高速になることが多い。
  
  ## どのような列に対してインデックスを作成すべきか
  ### 一般的にインデックスの効果が高い列
  - WHERE句でよく使われる列
  - ORDER BY句でよく使われる列
  - JOINの結合条件によく使われる列
  
  ## 基準となる概念
  - カーディナリティ
  - 選択率
  
  ### カーディナリティとは
  - 値のばらつき具合を示す概念
  - もっとも高いのはプライマリーキーなど一意キーの列
  
  ### 選択率とは
  - 選択率 = 絞り込んだ件数 / 総データ件数
  - 具体的な閾値は5%~10%前後
  - 5%未満で絞り込める条件であればインデックスを貼る価値がある(かも)
  
  ## 選択率の高いケースの対処法
  ### インデックスオンリースキャン
  - 必要な列をインデックスするだけで充足する場合にテーブルへのアクセスをスキップする技術
  - 特定の複数列をカバーするインデックス(カバリングインデックス)を作成
  - ひとつのインデックスに含められる列数には限りがある
  - 更新時にテーブルのオーバーヘッドを増やす
  
  ### データマート(サマリテーブル)を作成
  - データ鮮度(どのタイミングで同期するか)の運用上の難しさや、テーブルサイズ(オリジナルとのサイズとあまり変わらない場合)によっては効果が薄い、など副作用も考慮する必要がある
  
  ## インデックス作成のデメリット
  - 索引情報保存のため、ディスク容量を消費する
  - テーブルのデータ変更があるとインデックスの書き換えも必要となり、INSERT,UPDATE,DELETE文のオーバーヘッドが増す。
  
  
  ### その他
  参考図書 : [SQL実践入門──高速でわかりやすいクエリの書き方](http://amzn.asia/bjYs5bj)
  参考図書 : [スッキリわかるSQL入門](http://amzn.asia/d/diFEu7A)
  
  ### 内部表
  ### 駆動表
  ### 内部結合(inner join)
  ### 左外部結合(left after join)
  ### 複合インデックス
'''
linesHighlighted: []
isStarred: false
isTrashed: false
